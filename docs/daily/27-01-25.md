---
aliases: []
---
### Installer et lancer Open-Webui

```batch title:"Ollama"
docker run -d --network=host -v open-webui:/app/backend/data -e OLLAMA_BASE_URL=http://127.0.0.1:11434 --name open-webui --restart always ghcr.io/open-webui/open-webui:ollama
```

```batch title:"Ollama"
docker run -d --network=host --gpus=all -v ollama:/root/.ollama -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:ollama
```

```batch title:"With Image Generation"
docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -e AUTOMATIC1111_BASE_URL=http://host.docker.internal:7860/ -e ENABLE_IMAGE_GENERATION=True -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main
```

## Scripts Powershell

```Powershell title:"Écrire du contenu dans un fichier"
#Défini le chemin du répertoire
$folder = "C:\Users\Coockiepickle"

#Supprime le dossier du script précédent
Remove-Item -Recurse "$folder\Test"
Write-Output " "
Write-Output "Un dossier 'Test' existe déjà, il a donc été supprimé"

#Créer le dossier "Test"
New-Item -ItemType directory -Path $folder -Name Test

#Vérifie que le dossier a été crée
if (Test-Path -Path $folder) {
    Write-Output " "
    Write-Output "Dossier crée avec succès"
    Write-Output " "
    } else {
    Write-Output "Le dossier n'a pas été crée"
    }

#Défini le chemin du fichier txt
$filePath = "$folder\Test\coucou.txt"

#Contenu à écrire dans le fichier txt
Write-Output " "
$content = "La vie, c'est comme une boîte de chocolat"

#Ajoute le contenu dans le fichier txt
Add-Content -Path $filePath -Value $content

#Affiche le contenu du fichier txt
Write-Output "Le fichier a été crée"
Write-Output " "
Write-Output "Le fichier contient : "
Write-Output " "
Get-Content -Path $filePath
```

```Powershell title:"Tester si un nombre est pair ou impair"
# Fonction pour tester si le chiffre est pair ou impair
function testPairImpair {
    param (
        [int]$nbr
    )
    # Teste le modulo du chiffre par 2
    $resultat = ($nbr % 2)
    # Retourne pair ou impair en fonction du résultat
    if ($resultat -eq 0) {
        return "$nbr est pair"
    } else {
        return "$nbr est impair"
    }
}

# Défini le chemin du fichier txt
$fichier = "C:\Users\Coockiepickle\Test\pairimpair.txt"

# Boucle for de 1 à 10
for ($i = 1; $i -le 10; $i++) {
    # Appelle la fonction pour chaque valeur de i et stocke le résultat
    $res = testPairImpair $i

    # Écrit le résultat de chaque chiffre à la fin du fichier
    Add-Content -Path $fichier -Value $res
}
```

```Powershell title:"Mineur ou majeur"
#Demande l'âge de l'utilisateur
$age = Read-Host "Quel âge avez-vous ?"

#Compare l'âge avec la majorité
if ($age -lt 18) {
    Write-Output "Vous êtes mineur"
    } else {
    Write-Output "Vous êtes majeur"
    }
```

```Powershell title:"Liste de pays"
# Liste des pays
$liste_pays = @("France", "Angleterre", "Brésil", "Japon", "États-Unis", "Chine", "Irlande", "Allemagne")

# Affiche les pays de la liste
foreach ($pays in $liste_pays) {
    Write-Output $pays
}
```

```Powershell title:"Lister les fichiers"
#Supprime le dossier du script précédent
Remove-Item -Recurse "$folderPath\Rapport_Fichiers"

$folderPath = "C:\Users\$Env:UserName"

# Créer répertoire
New-Item -ItemType directory -Name "Rapport_Fichiers" -Path $folderPath

# Récupère la liste des dossiers
$liste_rep = @(Get-ChildItem "$folderPath\Documents")

# Écrire la liste dans un fichier txt
$rapport = "$folderPath\Rapport_Fichiers\rapport.txt"
foreach ($item in $liste_rep) {
    $name = $item.Name
    $length = $item.Length
    $creationTime = $item.CreationTime
    $name, $length, $creationTime | Out-File -FilePath $rapport -Append
}

Write-Output "Les données ont été écrites dans $rapport"
```

```Powershell title:"Surveillance utilisation RAM"
# Obtenir la mémoire totale du système
$TotalMemory = (Get-CimInstance -ClassName Win32_ComputerSystem).TotalPhysicalMemory

# Convertir la mémoire totale en Mo
$TotalMemoryMB = [math]::Round($TotalMemory / 1MB, 2)

Write-Output "Mémoire totale disponible : $TotalMemoryMB MB"

while ($true) {
    Clear-Host
    Write-Output "Vérification de l'utilisation de la mémoire en temps réel..."

    # Récupérer tous les processus utilisateur et leur utilisation mémoire
    $processes = Get-Process | Where-Object { $_.Path -ne $null } | Select-Object Name, @{Name='MemoryMB';Expression={[math]::Round($_.WorkingSet / 1MB, 2)}}

    foreach ($process in $processes) {
        # Calculer le pourcentage de mémoire utilisée par chaque processus
        $memoryUsagePercent = ($process.MemoryMB / $TotalMemoryMB) * 100

        # Afficher les informations du processus avec alignement des colonnes
        $name = $process.Name.PadRight(30)
        $memory = "$($process.MemoryMB) MB".PadLeft(15)
        Write-Output "Nom : $name | $memory"

        # Alerte si le processus utilise plus de 80% de la mémoire
        if ($memoryUsagePercent -gt 80) {
            Write-Warning "Alerte: Le processus $($process.Name)) utilise plus de 80% de la mémoire du système!"
        }
    }

    Start-Sleep -Seconds 5  # Pause de 5 secondes avant la prochaine vérification
}
```
